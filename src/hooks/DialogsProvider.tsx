import React from "react";
import type { DialogComponent, OpenDialog, OpenDialogOptions } from "../types/dialog";
import { DialogsContext } from "../types/DialogContext";
import { useEventCallback } from "@mui/material";

interface DialogStackEntry<P, R> {
    key: string;
    open: boolean;
    promise: Promise<R>;
    Component: DialogComponent<P, R>;
    payload: P;
    onClose: (result: R) => Promise<void>;
    resolve: (result: R) => void;
}

export interface DialogProviderProps {
    children?: React.ReactNode;
    unmountAfter?: number;
}

export default function DialogsProvider(props: DialogProviderProps) {
    const { children, unmountAfter = 1000 } = props;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const [stack, setStack] = React.useState<DialogStackEntry<any, any>[]>([]);
    const keyPrefix = React.useId();
    const nextId = React.useRef(0);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const dialogMetadata = React.useRef(new WeakMap<Promise<any>, DialogStackEntry<any, any>>());

    const requestDialog = useEventCallback<OpenDialog>(function open<P, R>(
        Component: DialogComponent<P, R>,
        payload: P,
        options: OpenDialogOptions<R> = {}
    ) {
        const { onClose = async () => { } } = options;
        let resolve: ((result: R) => void) | undefined;
        const promise = new Promise<R>((resolveImpl) => {
            resolve = resolveImpl;
        });

        if (!resolve) {
            throw new Error('resolve not set.');
        }

        const key = `${keyPrefix}-${nextId.current}`;
        nextId.current += 1;

        const newEntry: DialogStackEntry<P, R> = {
            key,
            open: true,
            promise,
            Component,
            payload,
            onClose,
            resolve
        };

        dialogMetadata.current.set(promise, newEntry);
        setStack((prevStack) => [...prevStack, newEntry]);
        return promise;
    });

    const closeDialogUi = useEventCallback(function closeDialogUi<R>(dialog: Promise<R>) {
        setStack((prevStack) =>
            prevStack.map((entry) =>
                entry.promise === dialog ? { ...entry, open: false } : entry,
            )
        );
        setTimeout(() => {
            setStack((prevStack) => prevStack.filter((entry) => entry.promise !== dialog));
        }, unmountAfter);
    });

    const closeDialog = useEventCallback(async function closeDialog<R>(dialog: Promise<R>, result: R) {
        const entryToClose = dialogMetadata.current.get(dialog);
        if (!entryToClose) {
            throw new Error('Dialog not found.');
        }

        try {
            await entryToClose.onClose(result);
        } finally {
            entryToClose.resolve(result);
            closeDialogUi(dialog);
        }
        return dialog;
    });

    const contextValue = React.useMemo(() => ({ open: requestDialog, close: closeDialog }), [requestDialog, closeDialog]);

    return (
        <DialogsContext.Provider value={contextValue}>
            {children}
            {
                stack.map(({ key, open, Component, payload, promise }) => (
                    <Component
                        key={key}
                        payload={payload}
                        open={open}
                        onClose={async (result) => {
                            await closeDialog(promise, result);
                        }}
                    />
                ))
            }
        </DialogsContext.Provider>
    );
}